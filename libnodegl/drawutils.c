/*
 * Copyright 2019 GoPro Inc.
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <math.h>
#include <float.h>

#include "drawutils.h"
#include "memory.h"
#include "nodegl.h"
#include "utils.h"

#define BYTES_PER_PIXEL 4 /* RGBA */

static const uint8_t font8[128][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00},
    {0x00, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x14, 0x3e, 0x14, 0x14, 0x3e, 0x14, 0x00},
    {0x08, 0x3c, 0x0a, 0x1c, 0x28, 0x28, 0x1e, 0x08}, {0x00, 0x00, 0x22, 0x10, 0x08, 0x04, 0x22, 0x00},
    {0x00, 0x0c, 0x12, 0x0c, 0x52, 0x32, 0x6c, 0x00}, {0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x18, 0x04, 0x04, 0x04, 0x04, 0x18, 0x00}, {0x00, 0x0c, 0x10, 0x10, 0x10, 0x10, 0x0c, 0x00},
    {0x08, 0x2a, 0x1c, 0x7f, 0x1c, 0x2a, 0x08, 0x00}, {0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02}, {0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00}, {0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00},
    {0x00, 0x1c, 0x32, 0x2a, 0x2a, 0x26, 0x1c, 0x00}, {0x00, 0x08, 0x0c, 0x08, 0x08, 0x08, 0x1c, 0x00},
    {0x00, 0x1c, 0x22, 0x20, 0x1c, 0x02, 0x3e, 0x00}, {0x00, 0x1c, 0x22, 0x18, 0x20, 0x22, 0x1c, 0x00},
    {0x00, 0x18, 0x14, 0x12, 0x3e, 0x10, 0x38, 0x00}, {0x00, 0x3e, 0x02, 0x1e, 0x20, 0x22, 0x1c, 0x00},
    {0x00, 0x3c, 0x02, 0x1e, 0x22, 0x22, 0x1c, 0x00}, {0x00, 0x3e, 0x20, 0x10, 0x08, 0x04, 0x04, 0x00},
    {0x00, 0x1c, 0x22, 0x1c, 0x22, 0x22, 0x1c, 0x00}, {0x00, 0x1c, 0x22, 0x22, 0x3c, 0x20, 0x1e, 0x00},
    {0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 0x00}, {0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 0x02},
    {0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00}, {0x00, 0x00, 0x3e, 0x00, 0x00, 0x3e, 0x00, 0x00},
    {0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, 0x00}, {0x00, 0x1c, 0x22, 0x20, 0x18, 0x04, 0x00, 0x04},
    {0x00, 0x3c, 0x22, 0x3a, 0x1a, 0x42, 0x3c, 0x00}, {0x00, 0x1c, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x00},
    {0x00, 0x1e, 0x22, 0x1e, 0x22, 0x22, 0x1e, 0x00}, {0x00, 0x3c, 0x02, 0x02, 0x02, 0x02, 0x3c, 0x00},
    {0x00, 0x1e, 0x22, 0x22, 0x22, 0x22, 0x1e, 0x00}, {0x00, 0x3e, 0x02, 0x1e, 0x02, 0x02, 0x3e, 0x00},
    {0x00, 0x3e, 0x02, 0x1e, 0x02, 0x02, 0x02, 0x00}, {0x00, 0x1c, 0x22, 0x02, 0x32, 0x22, 0x3c, 0x00},
    {0x00, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x22, 0x00}, {0x00, 0x1c, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x00},
    {0x00, 0x20, 0x20, 0x20, 0x20, 0x22, 0x1c, 0x00}, {0x00, 0x12, 0x0a, 0x06, 0x0a, 0x12, 0x22, 0x00},
    {0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x3e, 0x00}, {0x00, 0x22, 0x36, 0x2a, 0x22, 0x22, 0x22, 0x00},
    {0x00, 0x22, 0x26, 0x2a, 0x32, 0x22, 0x22, 0x00}, {0x00, 0x1c, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00},
    {0x00, 0x1e, 0x22, 0x22, 0x1e, 0x02, 0x02, 0x00}, {0x00, 0x1c, 0x22, 0x22, 0x22, 0x1c, 0x30, 0x00},
    {0x00, 0x1e, 0x22, 0x22, 0x1e, 0x22, 0x22, 0x00}, {0x00, 0x3c, 0x02, 0x1c, 0x20, 0x20, 0x1e, 0x00},
    {0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, {0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00},
    {0x00, 0x22, 0x22, 0x22, 0x14, 0x14, 0x08, 0x00}, {0x00, 0x22, 0x22, 0x22, 0x2a, 0x36, 0x22, 0x00},
    {0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00}, {0x00, 0x22, 0x22, 0x22, 0x14, 0x08, 0x08, 0x00},
    {0x00, 0x3e, 0x10, 0x08, 0x04, 0x02, 0x3e, 0x00}, {0x00, 0x1c, 0x04, 0x04, 0x04, 0x04, 0x1c, 0x00},
    {0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00}, {0x00, 0x1c, 0x10, 0x10, 0x10, 0x10, 0x1c, 0x00},
    {0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00},
    {0x00, 0x02, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x3c, 0x22, 0x22, 0x22, 0x5c, 0x00},
    {0x02, 0x02, 0x1e, 0x22, 0x22, 0x22, 0x1e, 0x00}, {0x00, 0x00, 0x1c, 0x22, 0x02, 0x02, 0x3c, 0x00},
    {0x20, 0x20, 0x3c, 0x22, 0x22, 0x22, 0x3c, 0x00}, {0x00, 0x00, 0x1c, 0x22, 0x3e, 0x02, 0x3c, 0x00},
    {0x00, 0x38, 0x04, 0x1e, 0x04, 0x04, 0x04, 0x00}, {0x00, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x20, 0x1e},
    {0x02, 0x02, 0x02, 0x1e, 0x22, 0x22, 0x22, 0x00}, {0x00, 0x04, 0x00, 0x06, 0x04, 0x04, 0x0c, 0x00},
    {0x00, 0x10, 0x00, 0x10, 0x10, 0x10, 0x12, 0x0c}, {0x02, 0x02, 0x12, 0x0a, 0x06, 0x0a, 0x12, 0x00},
    {0x0c, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x00}, {0x00, 0x00, 0x1e, 0x2a, 0x2a, 0x2a, 0x2a, 0x00},
    {0x00, 0x00, 0x1a, 0x26, 0x22, 0x22, 0x22, 0x00}, {0x00, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x1c, 0x00},
    {0x00, 0x00, 0x1e, 0x22, 0x22, 0x1e, 0x02, 0x02}, {0x00, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x20, 0x20},
    {0x00, 0x00, 0x1a, 0x26, 0x02, 0x02, 0x02, 0x00}, {0x00, 0x00, 0x3c, 0x02, 0x1c, 0x20, 0x1e, 0x00},
    {0x04, 0x04, 0x1e, 0x04, 0x04, 0x04, 0x18, 0x00}, {0x00, 0x00, 0x22, 0x22, 0x22, 0x32, 0x2c, 0x00},
    {0x00, 0x00, 0x22, 0x22, 0x14, 0x14, 0x08, 0x00}, {0x00, 0x00, 0x22, 0x2a, 0x2a, 0x2a, 0x14, 0x00},
    {0x00, 0x00, 0x22, 0x14, 0x08, 0x14, 0x22, 0x00}, {0x00, 0x00, 0x22, 0x22, 0x22, 0x3c, 0x20, 0x1e},
    {0x00, 0x00, 0x3e, 0x10, 0x08, 0x04, 0x3e, 0x00}, {0x18, 0x04, 0x04, 0x02, 0x04, 0x04, 0x18, 0x00},
    {0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, {0x0c, 0x10, 0x10, 0x20, 0x10, 0x10, 0x0c, 0x00},
    {0x00, 0x00, 0x00, 0x2c, 0x1a, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

static inline void set_color(uint8_t *p, uint32_t rgba)
{
    p[0] = rgba >> 24;
    p[1] = rgba >> 16 & 0xff;
    p[2] = rgba >>  8 & 0xff;
    p[3] = rgba       & 0xff;
}

static inline uint8_t *get_pixel_pos_buf(const struct canvas *canvas, int px, int py)
{
    return canvas->buf + (py * canvas->w + px) * BYTES_PER_PIXEL;
}

void ngli_drawutils_draw_rect(struct canvas *canvas, const struct rect *rect, uint32_t color)
{
    uint8_t *buf = get_pixel_pos_buf(canvas, rect->x, rect->y);
    const int stride = canvas->w * BYTES_PER_PIXEL;
    for (int y = 0; y < rect->h; y++) {
        for (int x = 0; x < rect->w; x++)
            set_color(buf + x * BYTES_PER_PIXEL, color);
        buf += stride;
    }
}

void ngli_drawutils_print(struct canvas *canvas, int x, int y, const char *str, uint32_t color)
{
    int px = 0, py = 0;
    for (int i = 0; str[i]; i++) {
        if (str[i] == '\n') {
            py++;
            px = 0;
            continue;
        }
        for (int char_y = 0; char_y < NGLI_FONT_H; char_y++) {
            for (int char_x = 0; char_x < NGLI_FONT_W; char_x++) {
                const int pix_x = x + px * NGLI_FONT_W + char_x;
                const int pix_y = y + py * NGLI_FONT_H + char_y;
                if (pix_x < 0 || pix_y < 0 || pix_x >= canvas->w || pix_y >= canvas->h)
                    continue;
                uint8_t *p = get_pixel_pos_buf(canvas, pix_x, pix_y);
                if (font8[str[i] & 0x7f][char_y] & (1 << char_x))
                    set_color(p, color);
            }
        }
        px++;
    }
}

#if 1
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

static int save_ppm(const char *filename, uint8_t *data, int width, int height)
{
    int ret = 0;
    int flags = O_WRONLY|O_CREAT|O_TRUNC;
#ifdef O_BINARY
    flags |= O_BINARY;
#endif
    int fd = open(filename, flags, 0644);
    if (fd == -1) {
        fprintf(stderr, "Unable to open '%s'\n", filename);
        return -1;
    }

    uint8_t *buf = malloc(32 + width * height * 3);
    if (!buf) {
        ret = -1;
        goto end;
    }

    const int header_size = snprintf((char *)buf, 32, "P5 %d %d 255\n", width, height);
    if (header_size < 0) {
        ret = -1;
        fprintf(stderr, "Failed to write PPM header\n");
        goto end;
    }

    uint8_t *dst = buf + header_size;
    memcpy(dst, data, width * height);

    const int size = header_size + width * height;
    ret = write(fd, buf, size);
    if (ret < 0) {
        fprintf(stderr, "Failed to write PPM data\n");
        goto end;
    }

end:
    free(buf);
    close(fd);
    return ret;
}
#endif

int ngli_drawutils_get_font_atlas(struct canvas *c_dst)
{
    struct canvas c = {.w = 16 * NGLI_FONT_W, .h = 8 * NGLI_FONT_H};
    c.buf = ngli_calloc(c.w * c.h, 1);
    if (!c.buf)
        return NGL_ERROR_MEMORY;

    uint8_t chr = 0;
    for (int y = 0; y < 8; y++) {
        for (int x = 0; x < 16; x++) {
            for (int char_y = 0; char_y < NGLI_FONT_H; char_y++) {
                for (int char_x = 0; char_x < NGLI_FONT_W; char_x++) {
                    const int pix_x = x * NGLI_FONT_W + char_x;
                    const int pix_y = y * NGLI_FONT_H + char_y;
                    uint8_t *p = c.buf + (pix_y * c.w + pix_x);
                    if (font8[chr][char_y] & (1 << char_x))
                        *p = 0xff;
                }
            }
            chr++;
        }
    }

    //save_ppm("/tmp/atlas.ppm", c.buf, c.w, c.h);

    *c_dst = c;
    return 0;
}

#define SCALE_BITS 2
#define DF_CHAR_GLYPH_W (NGLI_FONT_W << SCALE_BITS)
#define DF_CHAR_GLYPH_H (NGLI_FONT_H << SCALE_BITS)

/*
 * Spread is arbitrary: it represents how far an effect such as glowing could
 * be applied, but it's also used for padding around the glyph to be that the
 * extremities of the distance map are always black, and thus not affect
 * neighbor glyph, typically when relying on mipmapping.
 */
#define DF_SPREAD (1 << (3 + SCALE_BITS)) /* spread by 8 units (1<<3) */
#define DF_CHAR_PAD DF_SPREAD
#define DF_CHAR_W (DF_CHAR_GLYPH_W + DF_CHAR_PAD * 2)
#define DF_CHAR_H (DF_CHAR_GLYPH_H + DF_CHAR_PAD * 2)

#define DT_1D_LANE_SIZE NGLI_MAX(DF_CHAR_W, DF_CHAR_H)
#define INF FLT_MAX
#define SQ(x) ((x) * (x))
#define SRC(x) src[x * src_stride]
#define PARABOLLA(k) ((SRC(q) + SQ(q)) - (SRC(v[k]) + SQ(v[k]))) / (2 * q - 2 * v[k]);

/*
 * Direct implementation of the DT(f) algorithm presented in "Distance
 * Transforms of Sampled Functions" by Pedro F. Felzenszwalb and Daniel P.
 * Huttenlocher (2012).
 */
static void dt_1d(float *dst, int dst_stride, const float *src, int src_stride, int n)
{
    int k = 0;
    int v[DT_1D_LANE_SIZE] = {0};
    float z[DT_1D_LANE_SIZE + 1];

    z[0] = -INF;
    z[1] =  INF;
    for (int q = 1; q < n; q++) {
        float s = PARABOLLA(k);
        while (s <= z[k]) {
            k--;
            s = PARABOLLA(k);
        }
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = INF;
    }

    k = 0;
    for (int q = 0; q < n; q++) {
        while (z[k + 1] < q)
            k++;
        dst[q * dst_stride] = SQ(q - v[k]) + SRC(v[k]);
    }
}

static float clamp(double v, double min, double max)
{
    if (v < min) return min;
    if (v > max) return max;
    return v;
}

static void get_char_dt(uint8_t *dst, int dst_stride, uint8_t c)
{
    const uint8_t *bits = font8[c & 0x7f];
    float dt_ref[DF_CHAR_W * DF_CHAR_H];
    float dt_inv[DF_CHAR_W * DF_CHAR_H];
    float dt_tmp[DF_CHAR_W * DF_CHAR_H];

    for (int y = 0; y < DF_CHAR_H; y++) {
        for (int x = 0; x < DF_CHAR_W; x++) {
            int bit = 0;
            const int inside_glyph = x >= DF_CHAR_PAD && x < DF_CHAR_GLYPH_W + DF_CHAR_PAD &&
                                     y >= DF_CHAR_PAD && y < DF_CHAR_GLYPH_H + DF_CHAR_PAD;
            if (inside_glyph) {
                const int glyph_x = ((x - DF_CHAR_PAD) >> SCALE_BITS);
                const int glyph_y = ((y - DF_CHAR_PAD) >> SCALE_BITS);
                bit = bits[glyph_y] & (1 << glyph_x);
            }

            /* Set distance to 0 for the character, and infinite for the rest */
            dt_ref[y * DF_CHAR_W + x] = bit ? 0 : INF;

            /* Inverse of the above to be used for getting signed distances */
            dt_inv[y * DF_CHAR_W + x] = bit ? INF : 0;
        }
    }

    /* Vertical pass followed by Horizontal pass */
    for (int x = 0; x < DF_CHAR_W; x++)
        dt_1d(dt_tmp + x, DF_CHAR_W, dt_ref + x, DF_CHAR_W, DF_CHAR_H);
    for (int y = 0; y < DF_CHAR_H; y++)
        dt_1d(dt_ref + y*DF_CHAR_W, 1, dt_tmp + y*DF_CHAR_W, 1, DF_CHAR_W);

    /* Same thing with the inverse distances */
    for (int x = 0; x < DF_CHAR_W; x++)
        dt_1d(dt_tmp + x, DF_CHAR_W, dt_inv + x, DF_CHAR_W, DF_CHAR_H);
    for (int y = 0; y < DF_CHAR_H; y++)
        dt_1d(dt_inv + y*DF_CHAR_W, 1, dt_tmp + y*DF_CHAR_W, 1, DF_CHAR_W);

    /* Subtract inverse Dt from the ref to get the signed distance field (SDF).
     * The square root computations and normalization are also slipped in at
     * this step. */
    const float scale = -1.f / DF_SPREAD;
    for (int i = 0; i < NGLI_ARRAY_NB(dt_ref); i++)
        dt_ref[i] = clamp((sqrtf(dt_ref[i]) - sqrtf(dt_inv[i])) * scale, -1.f, 1.f);

    // Rescale from [-1;1] to [0;255] and write to the destination
    // XXX: clarify far-inside, far-outside
    const float *src = dt_ref;
    for (int y = 0; y < DF_CHAR_H; y++) {
        for (int x = 0; x < DF_CHAR_W; x++) {
            const float scaled_v = (*src++ + 1.f) * .5f;
            const long int v = lrintf(scaled_v * 255);
            dst[x] = NGLI_MIN(NGLI_MAX(v, 0), 255);
        }
        dst += dst_stride;
    }
}

static unsigned next_pow2(unsigned v)
{
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    return v + 1;
}

#define ATLAS_COLS 16
#define ATLAS_ROWS  8
#define ATLAS_W (ATLAS_COLS * DF_CHAR_W)
#define ATLAS_H (ATLAS_ROWS * DF_CHAR_H)

void ngli_drawutils_get_atlas_uvcoords(const struct canvas *c, uint8_t chr, float *dst)
{
    //ngli_assert(c->w == c->h);
    const float scale_w = 1.f / c->w;
    const float scale_h = 1.f / c->h;
    const int col = chr % ATLAS_COLS;
    const int row = chr / ATLAS_COLS; // from the top of the buffer
    const float cx =              (col * DF_CHAR_W + DF_CHAR_PAD) * scale_w;
    const float cy = (c->h - (row + 1) * DF_CHAR_H + DF_CHAR_PAD) * scale_h;
    const float cw = DF_CHAR_GLYPH_W * scale_w;
    const float ch = DF_CHAR_GLYPH_H * scale_h;
    const float chr_uvs[] = {
        cx,      1.f - cy,
        cx + cw, 1.f - cy,
        cx + cw, 1.f - cy - ch,
        cx,      1.f - cy - ch,
    };
    memcpy(dst, chr_uvs, sizeof(chr_uvs));
}

int ngli_drawutils_get_font_atlas_dt(struct canvas *c_dst)
{
    const int s = next_pow2(NGLI_MAX(ATLAS_W, ATLAS_H));
    struct canvas c = {.w = s, .h = s};
    c.buf = ngli_calloc(c.w * c.h, 1);
    if (!c.buf)
        return NGL_ERROR_MEMORY;

    uint8_t chr = 0;
    for (int y = 0; y < 8; y++) {
        for (int x = 0; x < 16; x++) {
            uint8_t *p = c.buf + (y * c.w * DF_CHAR_H + x * DF_CHAR_W);
            get_char_dt(p, c.w, chr++);
        }
    }

    save_ppm("/tmp/atlas_dt.ppm", c.buf, c.w, c.h);

    *c_dst = c;

    return 0;
}
